#include <cassert>
#include <iosfwd>
#include <memory>
#include <stdexcept>
#include <string>
#include <utility>
#include <vector>

#include <ddl_migration_msg.h>
#include <ddl_names.h>
#include <ddl_table_migrator.h>

#include "dbunit_pkvsid_ddl_table_migrator.h"

namespace middle {
using namespace std;
using namespace normal_ddl;

ddl_datatype_migration
dbunit_pkvsid_ddl_table_migrator_impl::migrate_datatype_ddl(const ddl_cname& cname, ddl_datatype& datatype, bool nullable, const string& default_value, bool identity) {
  ddl_datatype_migration datatype_migration{ddl_table_migrator::migrate_datatype_ddl(cname, datatype, nullable, default_value, identity)};
  if (!datatype_migration.column_rejected) {
    string identity_clause;
    if (identity) {
      for (const auto& pk_cname : pk_cnames) {
        if (pk_cname == cname) {
          if (pk_cnames.size() == 1)
            pk_cnames.clear();
          break;
        }
      }
      if (!pk_cnames.empty()) {
        datatype_migration.msgs.push_back(ddl_migration_msg{ddl_migration_msg_level::error, "conflict between identity column '" + cname.str() + "' and other primary keys: any identity column must be a table's sole primary key"});
        datatype_migration.column_rejected = true;
        identity_cnames.clear();
      } else if (identity_cnt) {
        datatype_migration.msgs.push_back(ddl_migration_msg{ddl_migration_msg_level::error, "conflict between identity column '" + cname.str() + "' and other identities: only one identity column may exist per table"});
        datatype_migration.column_rejected = true;
        identity_cnames.clear();
      } else {
        identity_clause = "GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)";
        identity_cnames.push_back(cname);
      }
      datatype_migration.identity_clause = move(identity_clause);
      ++identity_cnt;
    }
  } else {
    const auto cend = pk_cnames.cend();
    for (auto cit = pk_cnames.cbegin(); cit != cend; ++cit) {
      if (*cit == cname) {
        pk_cnames.erase(cit);
        break;
      }
    }
  }
  return datatype_migration;
}

vector<ddl_cname>
dbunit_pkvsid_ddl_table_migrator_impl::filter_pk_columns() {
  if (filter_pk_columns_called)
    throw logic_error{string{"filter_pk_columns already called"}};
  filter_pk_columns_called = true;
  return move(pk_cnames);
}

vector<ddl_cname>
dbunit_pkvsid_ddl_table_migrator_impl::uniquify_identity_columns() {
  if (uniquify_identity_columns_called)
    throw logic_error{string{"uniquify_identity_columns already called"}};
  uniquify_identity_columns_called = true;
  assert(identity_cnames.size() <= 1);
  return move(identity_cnames);
}

unique_ptr<ddl_table_migrator>
dbunit_pkvsid_ddl_table_migrator_factory_impl::make_table_migrator(const ddl_stname& stname, const vector<ddl_cname>& pk_cnames, ostream* verbose_os) {
  return unique_ptr<ddl_table_migrator>{new dbunit_pkvsid_ddl_table_migrator_impl{table_migrator_prefs, stname, pk_cnames, verbose_os}};
}
}
