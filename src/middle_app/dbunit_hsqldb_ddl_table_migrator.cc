#include <iosfwd>
#include <memory>
#include <stdexcept>
#include <string>
#include <utility>
#include <vector>

#include <ddl_names.h>
#include <ddl_table_migrator.h>

#include "dbunit_hsqldb_ddl_table_migrator.h"

namespace middle {
using namespace std;
using namespace normal_ddl;

ddl_datatype_migration
dbunit_hsqldb_ddl_table_migrator_impl::migrate_datatype_ddl(const ddl_cname& cname, ddl_datatype& datatype, bool nullable, const string& default_value, bool identity) {
  ddl_datatype_migration datatype_migration{ddl_table_migrator::migrate_datatype_ddl(cname, datatype, nullable, default_value, identity)};
  if (!datatype_migration.column_rejected) {
    if (identity)
      datatype_migration.identity_clause = "GENERATED BY DEFAULT AS IDENTITY(START WITH 1, INCREMENT BY 1)";
  } else {
    const auto cend = pk_cnames.cend();
    for (auto cit = pk_cnames.cbegin(); cit != cend; ++cit) {
      if (*cit == cname) {
        pk_cnames.erase(cit);
        break;
      }
    }
  }
  return datatype_migration;
}

vector<ddl_cname>
dbunit_hsqldb_ddl_table_migrator_impl::filter_pk_columns() {
  if (filter_pk_columns_called)
    throw logic_error{string{"filter_pk_columns already called"}};
  filter_pk_columns_called = true;
  return move(pk_cnames);
}

vector<ddl_cname>
dbunit_hsqldb_ddl_table_migrator_impl::uniquify_identity_columns() {
  return vector<ddl_cname>{};
}

unique_ptr<ddl_table_migrator>
dbunit_hsqldb_ddl_table_migrator_factory_impl::make_table_migrator(const ddl_stname& stname, const vector<ddl_cname>& pk_cnames, ostream* verbose_os) {
  return unique_ptr<ddl_table_migrator>{new dbunit_hsqldb_ddl_table_migrator_impl{table_migrator_prefs, stname, pk_cnames, verbose_os}};
}
}
